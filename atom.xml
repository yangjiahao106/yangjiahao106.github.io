<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨家浩</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-19T14:46:53.860Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yangjiahao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用快速排序解决TopK问题和数据流的中位数</title>
    <link href="http://yoursite.com/2019/01/19/%E4%BD%BF%E7%94%A8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%A7%A3%E5%86%B3TopK%E9%97%AE%E9%A2%98%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
    <id>http://yoursite.com/2019/01/19/使用快速排序解决TopK问题和数据流的中位数/</id>
    <published>2019-01-19T13:57:31.000Z</published>
    <updated>2019-01-19T14:46:53.860Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用快排思想解决TopK问题和数据流的中位数"><a href="#使用快排思想解决TopK问题和数据流的中位数" class="headerlink" title="使用快排思想解决TopK问题和数据流的中位数"></a>使用快排思想解决TopK问题和数据流的中位数</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序这里就不多介绍了，Partition函数为快速排序的核心函数，负责选择一个数字将比这个数字小的数字放到左边，大的数字放到右边，最后返回这个数字的下标，下面为使用golang 实现的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">QuickSort</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> start == end &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">index := Partition(nums, start, end)</span><br><span class="line"><span class="keyword">if</span> index &gt; start &#123;</span><br><span class="line">QuickSort(nums, start, index<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> index &lt; end &#123;</span><br><span class="line">QuickSort(nums, index+<span class="number">1</span>, end)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Partition 函数用于快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Partition</span><span class="params">(nums []<span class="keyword">int</span>, start, end <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="comment">//随机生成一个下标，此下标中的值作为中间值</span></span><br><span class="line"><span class="keyword">if</span> start &gt;= end &#123;</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line">index := rand.Intn(end-start) + start</span><br><span class="line">nums[index], nums[end] = nums[end], nums[index]</span><br><span class="line">small := start</span><br><span class="line"><span class="keyword">for</span> index = start; index &lt; end; index++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[index] &gt; nums[end] &#123;</span><br><span class="line"><span class="keyword">if</span> small != index &#123;</span><br><span class="line">nums[index], nums[small] = nums[small], nums[index]</span><br><span class="line">&#125;</span><br><span class="line">small++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//small++</span></span><br><span class="line">nums[small], nums[end] = nums[end], nums[small]</span><br><span class="line"><span class="comment">// 返回中间值的下标</span></span><br><span class="line"><span class="keyword">return</span> small</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Top-K-问题：最大的K个数字"><a href="#Top-K-问题：最大的K个数字" class="headerlink" title="Top K 问题：最大的K个数字"></a>Top K 问题：最大的K个数字</h2><p>使用快速排序的分治思想可以将这个问题的时间复杂度降低到O(n)</p><p><strong>减治法</strong> : 减治法比分治法效率更高，相比于分治法，减治法只需要解决分治之后其中一个<strong>子问题</strong>，而分治法需要解决分治后的所有子问题，所以它的时间复杂度为O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TopK</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums == <span class="literal">nil</span> || <span class="built_in">len</span>(nums) ==<span class="number">0</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; </span><br><span class="line">start := <span class="number">0</span></span><br><span class="line">end := <span class="built_in">len</span>(nums) <span class="number">-1</span></span><br><span class="line">index := Partition(nums, start, end)</span><br><span class="line"><span class="keyword">for</span> index != k<span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> index &gt; k<span class="number">-1</span> &#123;</span><br><span class="line">end = index<span class="number">-1</span></span><br><span class="line">index = Partition(nums, start, end)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = index + <span class="number">1</span></span><br><span class="line">index = Partition(nums, start, end)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> nums[<span class="number">0</span>:k]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无序数组的中位数"><a href="#无序数组的中位数" class="headerlink" title="无序数组的中位数"></a>无序数组的中位数</h2><p>如果数组的个数为奇数则中位数为排序后位于中间的那个数字， 如果个数为偶数，则中位数为排序后中间两个数字的平均值，所以要分两种情况。</p><p>此问题同样可以使用快排的partition函数解决，时间复杂度为O(n)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMedian</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> nums == <span class="literal">nil</span> || <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums)&amp;<span class="number">1</span> == <span class="number">1</span> &#123; <span class="comment">// 长度为奇数</span></span><br><span class="line">mid := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">index := Partition(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> index != mid &#123;</span><br><span class="line"><span class="keyword">if</span> index &lt; mid &#123;</span><br><span class="line">index = Partition(nums, index+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">index = Partition(nums, <span class="number">0</span>, index<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">float64</span>(nums[mid])</span><br><span class="line">        </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 长度为偶数</span></span><br><span class="line">midR := <span class="built_in">len</span>(nums) / <span class="number">2</span></span><br><span class="line">midL := (<span class="built_in">len</span>(nums) / <span class="number">2</span>) - <span class="number">1</span></span><br><span class="line">res := <span class="number">0</span></span><br><span class="line">findL, findR := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">start := <span class="number">0</span></span><br><span class="line">end := <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">index := Partition(nums, <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> !findL || !findR &#123;</span><br><span class="line"><span class="keyword">if</span> index &lt; midL &#123;</span><br><span class="line">start = index + <span class="number">1</span></span><br><span class="line">index = Partition(nums, start, end)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> index &gt; midR &#123;</span><br><span class="line">end = index - <span class="number">1</span></span><br><span class="line">index = Partition(nums, start, end)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> index == midL &#123;</span><br><span class="line">res += nums[midL]</span><br><span class="line">findL = <span class="literal">true</span></span><br><span class="line">start = index + <span class="number">1</span></span><br><span class="line">fmt.Println(start, end, midL)</span><br><span class="line">index = Partition(nums, start, end)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> index == midR &#123;</span><br><span class="line">res += nums[midR]</span><br><span class="line">findR = <span class="literal">true</span></span><br><span class="line">end = index - <span class="number">1</span></span><br><span class="line">fmt.Println(start, end)</span><br><span class="line">index = Partition(nums, start, end)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">float64</span>(res) / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用快排思想解决TopK问题和数据流的中位数&quot;&gt;&lt;a href=&quot;#使用快排思想解决TopK问题和数据流的中位数&quot; class=&quot;headerlink&quot; title=&quot;使用快排思想解决TopK问题和数据流的中位数&quot;&gt;&lt;/a&gt;使用快排思想解决TopK问题和数据流的中
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>golang 最大堆和最小堆</title>
    <link href="http://yoursite.com/2019/01/15/golang-%E6%9C%80%E5%A4%A7%E5%A0%86%E5%92%8C%E6%9C%80%E5%B0%8F%E5%A0%86/"/>
    <id>http://yoursite.com/2019/01/15/golang-最大堆和最小堆/</id>
    <published>2019-01-15T14:32:24.000Z</published>
    <updated>2019-01-17T08:35:46.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小堆和最大堆-golang实现"><a href="#最小堆和最大堆-golang实现" class="headerlink" title="最小堆和最大堆 golang实现"></a>最小堆和最大堆 golang实现</h1><p>二叉堆是一种特殊的堆，它满足两个性质：结构性和堆序性</p><ul><li>结构性：二叉堆是一颗完全二叉树，完全二叉树可以用一个数组表示，不需要指针，所以效率更高。当用数组表示时，数组中任一位置i上的元素，其左儿子在位置2i上，右儿子在位置(2i+ 1)上，其父节点在位置(i/2)上。</li><li>堆序性质：堆的最小值或最大值在根节点上，所以可以快速找到最大值或最小值。</li></ul><p>最大堆和最小堆是二叉堆的两种形式。<br>-最大堆：根结点的键值是所有堆结点键值中最大者的堆。<br>-最小堆：根结点的键值是所有堆结点键值中最小者的堆。</p><h1 id="1-最小堆实现，不使用container-heap"><a href="#1-最小堆实现，不使用container-heap" class="headerlink" title="1. 最小堆实现，不使用container/heap"></a>1. 最小堆实现，不使用container/heap</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MinHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">    Element []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定义构造方法"><a href="#定义构造方法" class="headerlink" title="定义构造方法"></a>定义构造方法</h2><p>数组中第一个元素不使用，存放一个小于堆中任何数字的值用于结束循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MinHeap构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMinHeap</span><span class="params">()</span> *<span class="title">MinHeap</span></span> &#123;</span><br><span class="line">    <span class="comment">// 第一个元素仅用于结束insert中的 for 循环</span></span><br><span class="line">    h := &amp;MinHeap&#123;Element: []<span class="keyword">int</span>&#123;math.MinInt64&#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入元素就直接将元素增加到堆的末尾，然后进行上浮操作，使二叉堆有序。<br>如果上浮一直到根，时间复杂度为O(log N)，但这种上浮操作一般结束的要早。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入数字,插入数字需要保证堆的性质</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(H *MinHeap)</span> <span class="title">Insert</span><span class="params">(v <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    H.Element = <span class="built_in">append</span>(H.Element, v)</span><br><span class="line">    i := <span class="built_in">len</span>(H.Element) - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 上浮</span></span><br><span class="line">    <span class="keyword">for</span> ; H.Element[i/<span class="number">2</span>] &gt; v; i /= <span class="number">2</span> &#123;</span><br><span class="line">        H.Element[i] = H.Element[i/<span class="number">2</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    H.Element[i] = v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h2><p>删除最大元素就直接从二叉堆顶端删除，然后进行下沉操作。最坏时间复杂度同样为O(log N)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除并返回最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(H *MinHeap)</span> <span class="title">DeleteMin</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(H.Element) &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"MinHeap is empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line">minElement := H.Element[<span class="number">1</span>]</span><br><span class="line">lastElement := H.Element[<span class="built_in">len</span>(H.Element)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">var</span> i, child <span class="keyword">int</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>; i*<span class="number">2</span> &lt; <span class="built_in">len</span>(H.Element); i = child &#123;</span><br><span class="line">child = i * <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span> child &lt; <span class="built_in">len</span>(H.Element)<span class="number">-1</span> &amp;&amp; H.Element[child+<span class="number">1</span>] &lt; H.Element[child] &#123;</span><br><span class="line">child ++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下滤一层</span></span><br><span class="line"><span class="keyword">if</span> lastElement &gt; H.Element[child] &#123;</span><br><span class="line">H.Element[i] = H.Element[child]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">H.Element[i] = lastElement</span><br><span class="line">H.Element = H.Element[:<span class="built_in">len</span>(H.Element)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> minElement, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(H *MinHeap)</span> <span class="title">Length</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(H.Element) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最小堆的最小值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(H *MinHeap)</span> <span class="title">Min</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(H.Element) &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> H.Element[<span class="number">1</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"heap is empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MinHeap格式化输出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(H *MinHeap)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v"</span>, H.Element[<span class="number">1</span>:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-下面介绍container-heap包-和最大堆的实现"><a href="#2-下面介绍container-heap包-和最大堆的实现" class="headerlink" title="2.下面介绍container/heap包 和最大堆的实现"></a>2.下面介绍container/heap包 和最大堆的实现</h1><h2 id="heap源码中定义了一个Interface-的接口，此接口一共包含五个方法，我们定义一个实现此接口的类就实现了一个二叉堆"><a href="#heap源码中定义了一个Interface-的接口，此接口一共包含五个方法，我们定义一个实现此接口的类就实现了一个二叉堆" class="headerlink" title="heap源码中定义了一个Interface 的接口，此接口一共包含五个方法，我们定义一个实现此接口的类就实现了一个二叉堆"></a>heap源码中定义了一个Interface 的接口，此接口一共包含五个方法，我们定义一个实现此接口的类就实现了一个二叉堆</h2><p>container/heap/heap.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">sort.Interface</span><br><span class="line">Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>sort.go<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line"><span class="comment">// Less reports whether the element with</span></span><br><span class="line"><span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line"><span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="定义一个最大堆，并实现heap-Interface-接口"><a href="#定义一个最大堆，并实现heap-Interface-接口" class="headerlink" title="定义一个最大堆，并实现heap.Interface 接口"></a>定义一个最大堆，并实现heap.Interface 接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(h)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h MaxHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 由于是最大堆，所以使用大于号</span></span><br><span class="line"><span class="keyword">return</span> h[i] &gt; h[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">(*h)[i], (*h)[j] = (*h)[j], (*h)[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop 弹出最后一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125;&#123;</span><br><span class="line">res := (*h)[<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line">*h = (*h)[:<span class="built_in">len</span>(*h)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试最大堆"><a href="#测试最大堆" class="headerlink" title="测试最大堆"></a>测试最大堆</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">h := <span class="built_in">make</span>(MaxHeap, <span class="number">0</span>)</span><br><span class="line">heap.Init(&amp;h)</span><br><span class="line"></span><br><span class="line">heap.Push(&amp;h, <span class="number">8</span>)</span><br><span class="line">heap.Push(&amp;h, <span class="number">1</span>)</span><br><span class="line">heap.Push(&amp;h, <span class="number">4</span>)</span><br><span class="line">heap.Push(&amp;h, <span class="number">5</span>)</span><br><span class="line">heap.Push(&amp;h, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(heap.Pop(&amp;h))</span><br><span class="line">fmt.Println(heap.Pop(&amp;h))</span><br><span class="line">fmt.Println(heap.Pop(&amp;h))</span><br><span class="line">fmt.Println(heap.Pop(&amp;h))</span><br><span class="line">fmt.Println(heap.Pop(&amp;h))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最小堆和最大堆-golang实现&quot;&gt;&lt;a href=&quot;#最小堆和最大堆-golang实现&quot; class=&quot;headerlink&quot; title=&quot;最小堆和最大堆 golang实现&quot;&gt;&lt;/a&gt;最小堆和最大堆 golang实现&lt;/h1&gt;&lt;p&gt;二叉堆是一种特殊的堆，它满足
      
    
    </summary>
    
    
  </entry>
  
</feed>
